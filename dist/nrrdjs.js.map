{"version":3,"file":"nrrdjs.js","sources":["../src/constants.js","../src/Parser.js","../src/index.js"],"sourcesContent":["/**\n * This is the mapping from the NRRD datatype as written in the NRRD header\n * to the JS typed array equivalent.\n */\nconst NRRD_TYPES_TO_TYPEDARRAY = {\n  \"signed char\": Int8Array,\n  \"int8\": Int8Array,\n  \"int8_t\": Int8Array,\n  \"uchar\": Uint8Array,\n  \"unsigned char\": Uint8Array,\n  \"uint8\": Uint8Array,\n  \"uint8_t\": Uint8Array,\n  \"short\": Int16Array,\n  \"short int\": Int16Array,\n  \"signed short\": Int16Array,\n  \"signed short int\": Int16Array,\n  \"int16\": Int16Array,\n  \"int16_t\": Int16Array,\n  \"ushort\": Uint16Array,\n  \"unsigned short\": Uint16Array,\n  \"unsigned short int\": Uint16Array,\n  \"uint16\": Uint16Array,\n  \"uint16_t\": Uint16Array,\n  \"int\": Int32Array,\n  \"signed int\": Int32Array,\n  \"int32\": Int32Array,\n  \"int32_t\": Int32Array,\n  \"uint\": Uint32Array,\n  \"unsigned int\": Uint32Array,\n  \"uint32\": Uint32Array,\n  \"uint32_t\": Uint32Array,\n  \"longlong\": BigInt64Array,           // OK for Node/V8/Chrome but not Firefox\n  \"long long\": BigInt64Array,\n  \"long long int\": BigInt64Array,\n  \"signed long long\": BigInt64Array,\n  \"signed long long int\": BigInt64Array,\n  \"int64\": BigInt64Array,\n  \"int64_t\": BigInt64Array,\n  \"ulonglong\": BigUint64Array,\n  \"unsigned long long\": BigUint64Array,\n  \"unsigned long long int\": BigUint64Array,\n  \"uint64\": BigUint64Array,\n  \"uint64_t\": BigUint64Array,\n  \"float\": Float32Array,\n  \"double\": Float64Array\n}\n\n\n/**\n * This is the mapping from the NRRD datatype as written in the NRRD header\n * to the JS DataView binary reading methods.\n */\nconst BUFFER_READ_METHODS = {\n  \"signed char\": {\n    \"little\": 'readInt8',\n    \"big\": 'readInt8'\n  },\n  \"int8\": {\n    \"little\": 'readInt8',\n    \"big\": 'readInt8'\n  },\n  \"int8_t\": {\n    \"little\": 'readInt8',\n    \"big\": 'readInt8'\n  },\n  \"uchar\": {\n    \"little\": 'readUInt8',\n    \"big\": 'readUInt8'\n  },\n  \"unsigned char\": {\n    \"little\": 'readUInt8',\n    \"big\": 'readUInt8'\n  },\n  \"uint8\": {\n    \"little\": 'readUInt8',\n    \"big\": 'readUInt8'\n  },\n  \"uint8_t\": {\n    \"little\": 'readUInt8',\n    \"big\": 'readUInt8'\n  },\n  \"short\": {\n    \"little\": 'readInt16LE',\n    \"big\": 'readInt16BE'\n  },\n  \"short int\": {\n    \"little\": 'readInt16LE',\n    \"big\": 'readInt16BE'\n  },\n  \"signed short\": {\n    \"little\": 'readInt16LE',\n    \"big\": 'readInt16BE'\n  },\n  \"signed short int\": {\n    \"little\": 'readInt16LE',\n    \"big\": 'readInt16BE'\n  },\n  \"int16\": {\n    \"little\": 'readInt16LE',\n    \"big\": 'readInt16BE'\n  },\n  \"int16_t\": {\n    \"little\": 'readInt16LE',\n    \"big\": 'readInt16BE'\n  },\n  \"ushort\": {\n    \"little\": 'readUInt16LE',\n    \"big\": 'readUInt16BE'\n  },\n  \"unsigned short\": {\n    \"little\": 'readUInt16LE',\n    \"big\": 'readUInt16BE'\n  },\n  \"unsigned short int\": {\n    \"little\": 'readUInt16LE',\n    \"big\": 'readUInt16BE'\n  },\n  \"uint16\": {\n    \"little\": 'readUInt16LE',\n    \"big\": 'readUInt16BE'\n  },\n  \"uint16_t\": {\n    \"little\": 'readUInt16LE',\n    \"big\": 'readUInt16BE'\n  },\n  \"int\": {\n    \"little\": 'readInt32LE',\n    \"big\": 'readInt32BE'\n  },\n  \"signed int\": {\n    \"little\": 'readInt32LE',\n    \"big\": 'readInt32BE'\n  },\n  \"int32\": {\n    \"little\": 'readInt32LE',\n    \"big\": 'readInt32BE'\n  },\n  \"int32_t\": {\n    \"little\": 'readInt32LE',\n    \"big\": 'readInt32BE'\n  },\n  \"uint\": {\n    \"little\": 'readUInt32LE',\n    \"big\": 'readUInt32BE'\n  },\n  \"unsigned int\": {\n    \"little\": 'readUInt32LE',\n    \"big\": 'readUInt32BE'\n  },\n  \"uint32\": {\n    \"little\": 'readUInt32LE',\n    \"big\": 'readUInt32BE'\n  },\n  \"uint32_t\": {\n    \"little\": 'readUInt32LE',\n    \"big\": 'readUInt32BE'\n  },\n  \"longlong\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },           // OK for Node/V8/Chrome but not Firefox\n  \"long long\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },\n  \"long long int\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },\n  \"signed long long\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },\n  \"signed long long int\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },\n  \"int64\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },\n  \"int64_t\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },\n  \"ulonglong\": {\n    \"little\": 'readBigUInt64LE',\n    \"big\": 'readBigUInt64BE'\n  },\n  \"unsigned long long\": {\n    \"little\": 'readBigUInt64LE',\n    \"big\": 'readBigUInt64BE'\n  },\n  \"unsigned long long int\": {\n    \"little\": 'readBigUInt64LE',\n    \"big\": 'readBigUInt64BE'\n  },\n  \"uint64\": {\n    \"little\": 'readBigUInt64LE',\n    \"big\": 'readBigUInt64BE'\n  },\n  \"uint64_t\": {\n    \"little\": 'readBigUInt64LE',\n    \"big\": 'readBigUInt64BE'\n  },\n  \"float\": {\n    \"little\": 'readFloatLE',\n    \"big\": 'readFloatBE'\n  },\n  \"double\": {\n    \"little\": 'readDoubleLE',\n    \"big\": 'readDoubleBE'\n  }\n}\n\n\nexport {\n  NRRD_TYPES_TO_TYPEDARRAY,\n  BUFFER_READ_METHODS\n}\n","import { NRRD_TYPES_TO_TYPEDARRAY, BUFFER_READ_METHODS } from './constants'\n\n\n/**\n * Parse a buffer of a NRRD file.\n * Throws an exception if the file is not a proper NRRD file.\n * @param {ArrayBuffer} nrrdBuffer - the NRRD file buffer\n * @param {Object} options - the option object\n * @param {boolean} options.headerOnly - Parses only the header if true, parses header and data if false (default: false)\n * @return {Object} NRRD header and data such as {header: Object, data: TypedArray }\n */\nexport default function parse(nrrdBuffer, options){\n  let magicControl = 'NRRD000'\n  let magicTest = String.fromCharCode.apply(null, new Uint8Array(nrrdBuffer, 0, magicControl.length))\n\n  if(magicControl !== magicTest){\n    throw new Error('This file is not a NRRD file')\n  }\n\n  let {header, dataByteOffset} = parseHeader(nrrdBuffer)\n\n  if('headerOnly' in options && options.headerOnly ){\n    return header\n  }\n\n  console.log(dataByteOffset)\n\n\n}\n\n\n/**\n * Parse the header\n */\nfunction parseHeader(nrrdBuffer){\n  let byteArrayHeader = []\n  let dataStartPosition = null\n  let view = new DataView(nrrdBuffer)\n\n  for(let i=0; i<nrrdBuffer.byteLength; i++){\n    byteArrayHeader.push(String.fromCharCode(view.getUint8(i)))\n\n    if(i>0 && byteArrayHeader[i-1] === '\\n' && byteArrayHeader[i] === '\\n'){\n      dataStartPosition = i + 1\n      break\n    }\n  }\n\n  let headerLines = byteArrayHeader.join('').trim().split('\\n').map(l => l.trim())\n\n\n  let preMap = headerLines.slice(1)\n  .filter( s => { // removing empty lines\n    return s.length > 0\n  })\n  .filter( s => { // removing comments\n    return (s[0] !== '#')\n  })\n  .map( s => {\n    let keyVal = s.split(':')\n    return {\n      key: keyVal[0].trim(),\n      val: keyVal[1].trim()\n    }\n  })\n\n  let nrrdHeader = {}\n  preMap.forEach( field => {\n    nrrdHeader[field.key] = field.val\n  })\n\n\n  // parsing each fields of the header\n  if(nrrdHeader['sizes']){\n    nrrdHeader['sizes'] = nrrdHeader.sizes.split(' ').map( n => parseInt(n))\n  }\n\n  if(nrrdHeader['space directions']){\n    nrrdHeader['space directions'] = nrrdHeader['space directions'].split(' ')\n        .map(triple => {\n          if(triple.trim() === 'none'){\n            return null\n          }\n          return triple.slice(1, triple.length-1)\n                       .split(',')\n                       .map(n => parseFloat(n))\n        })\n  }\n\n  if(nrrdHeader['dimension']){\n    nrrdHeader['dimension'] = parseInt(nrrdHeader['dimension'])\n  }\n\n  if(nrrdHeader['space origin']){\n    nrrdHeader['space origin'] = nrrdHeader['space origin']\n        .slice(1, nrrdHeader['space origin'].length-1)\n        .split(',')\n        .map(n => parseFloat(n))\n  }\n\n  if(nrrdHeader['kinds']){\n    nrrdHeader['kinds'] = nrrdHeader['kinds'].split(' ')\n  }\n\n  if(nrrdHeader['space dimension']){\n    nrrdHeader['space dimension'] = parseInt(nrrdHeader['space dimension'])\n  }\n\n  return {\n    header: nrrdHeader,\n    dataByteOffset: dataStartPosition\n  }\n}\n","import parse from './Parser'\n\nexport default ({\n  parse,\n})\n"],"names":[],"mappings":";;;;;;EAAA;EACA;EACA;EACA,GAAG;;ECAH;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACA,EAAe,SAAS,KAAK,CAAC,UAAU,EAAE,OAAO,CAAC;EAClD,EAAE,IAAI,YAAY,GAAG,UAAS;EAC9B,EAAE,IAAI,SAAS,GAAG,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,UAAU,CAAC,UAAU,EAAE,CAAC,EAAE,YAAY,CAAC,MAAM,CAAC,EAAC;;EAErG,EAAE,GAAG,YAAY,KAAK,SAAS,CAAC;EAChC,IAAI,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC;EACnD,GAAG;;EAEH,EAAE,IAAI,CAAC,MAAM,EAAE,cAAc,CAAC,GAAG,WAAW,CAAC,UAAU,EAAC;;EAExD,EAAE,GAAG,YAAY,IAAI,OAAO,IAAI,OAAO,CAAC,UAAU,EAAE;EACpD,IAAI,OAAO,MAAM;EACjB,GAAG;;EAEH,EAAE,OAAO,CAAC,GAAG,CAAC,cAAc,EAAC;;;EAG7B,CAAC;;;EAGD;EACA;EACA;EACA,SAAS,WAAW,CAAC,UAAU,CAAC;EAChC,EAAE,IAAI,eAAe,GAAG,GAAE;EAC1B,EAAE,IAAI,iBAAiB,GAAG,KAAI;EAC9B,EAAE,IAAI,IAAI,GAAG,IAAI,QAAQ,CAAC,UAAU,EAAC;;EAErC,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,UAAU,CAAC,UAAU,EAAE,CAAC,EAAE,CAAC;EAC5C,IAAI,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAC;;EAE/D,IAAI,GAAG,CAAC,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,eAAe,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC;EAC3E,MAAM,iBAAiB,GAAG,CAAC,GAAG,EAAC;EAC/B,MAAM,KAAK;EACX,KAAK;EACL,GAAG;;EAEH,EAAE,IAAI,WAAW,GAAG,eAAe,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAC;;;EAGlF,EAAE,IAAI,MAAM,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;EACnC,GAAG,MAAM,EAAE,CAAC,IAAI;EAChB,IAAI,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC;EACvB,GAAG,CAAC;EACJ,GAAG,MAAM,EAAE,CAAC,IAAI;EAChB,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC;EACzB,GAAG,CAAC;EACJ,GAAG,GAAG,EAAE,CAAC,IAAI;EACb,IAAI,IAAI,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,EAAC;EAC7B,IAAI,OAAO;EACX,MAAM,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;EAC3B,MAAM,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;EAC3B,KAAK;EACL,GAAG,EAAC;;EAEJ,EAAE,IAAI,UAAU,GAAG,GAAE;EACrB,EAAE,MAAM,CAAC,OAAO,EAAE,KAAK,IAAI;EAC3B,IAAI,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,IAAG;EACrC,GAAG,EAAC;;;EAGJ;EACA,EAAE,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;EACzB,IAAI,UAAU,CAAC,OAAO,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAC;EAC5E,GAAG;;EAEH,EAAE,GAAG,UAAU,CAAC,kBAAkB,CAAC,CAAC;EACpC,IAAI,UAAU,CAAC,kBAAkB,CAAC,GAAG,UAAU,CAAC,kBAAkB,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC;EAC9E,SAAS,GAAG,CAAC,MAAM,IAAI;EACvB,UAAU,GAAG,MAAM,CAAC,IAAI,EAAE,KAAK,MAAM,CAAC;EACtC,YAAY,OAAO,IAAI;EACvB,WAAW;EACX,UAAU,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;EACjD,wBAAwB,KAAK,CAAC,GAAG,CAAC;EAClC,wBAAwB,GAAG,CAAC,CAAC,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;EAC/C,SAAS,EAAC;EACV,GAAG;;EAEH,EAAE,GAAG,UAAU,CAAC,WAAW,CAAC,CAAC;EAC7B,IAAI,UAAU,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC,UAAU,CAAC,WAAW,CAAC,EAAC;EAC/D,GAAG;;EAEH,EAAE,GAAG,UAAU,CAAC,cAAc,CAAC,CAAC;EAChC,IAAI,UAAU,CAAC,cAAc,CAAC,GAAG,UAAU,CAAC,cAAc,CAAC;EAC3D,SAAS,KAAK,CAAC,CAAC,EAAE,UAAU,CAAC,cAAc,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;EACtD,SAAS,KAAK,CAAC,GAAG,CAAC;EACnB,SAAS,GAAG,CAAC,CAAC,IAAI,UAAU,CAAC,CAAC,CAAC,EAAC;EAChC,GAAG;;EAEH,EAAE,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;EACzB,IAAI,UAAU,CAAC,OAAO,CAAC,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,GAAG,EAAC;EACxD,GAAG;;EAEH,EAAE,GAAG,UAAU,CAAC,iBAAiB,CAAC,CAAC;EACnC,IAAI,UAAU,CAAC,iBAAiB,CAAC,GAAG,QAAQ,CAAC,UAAU,CAAC,iBAAiB,CAAC,EAAC;EAC3E,GAAG;;EAEH,EAAE,OAAO;EACT,IAAI,MAAM,EAAE,UAAU;EACtB,IAAI,cAAc,EAAE,iBAAiB;EACrC,GAAG;EACH,CAAC;;AC9GD,cAAe,CAAC;EAChB,EAAE,KAAK;EACP,CAAC,CAAC;;;;;;;;"}