{"version":3,"file":"nrrdjs.js","sources":["../src/constants.js","../src/Parser.js","../src/index.js"],"sourcesContent":["/**\n * This is the mapping from the NRRD datatype as written in the NRRD header\n * to the JS typed array equivalent.\n */\nconst NRRD_TYPES_TO_TYPEDARRAY = {\n  \"signed char\": Int8Array,\n  \"int8\": Int8Array,\n  \"int8_t\": Int8Array,\n  \"uchar\": Uint8Array,\n  \"unsigned char\": Uint8Array,\n  \"uint8\": Uint8Array,\n  \"uint8_t\": Uint8Array,\n  \"short\": Int16Array,\n  \"short int\": Int16Array,\n  \"signed short\": Int16Array,\n  \"signed short int\": Int16Array,\n  \"int16\": Int16Array,\n  \"int16_t\": Int16Array,\n  \"ushort\": Uint16Array,\n  \"unsigned short\": Uint16Array,\n  \"unsigned short int\": Uint16Array,\n  \"uint16\": Uint16Array,\n  \"uint16_t\": Uint16Array,\n  \"int\": Int32Array,\n  \"signed int\": Int32Array,\n  \"int32\": Int32Array,\n  \"int32_t\": Int32Array,\n  \"uint\": Uint32Array,\n  \"unsigned int\": Uint32Array,\n  \"uint32\": Uint32Array,\n  \"uint32_t\": Uint32Array,\n  \"longlong\": BigInt64Array,           // OK for Node/V8/Chrome but not Firefox\n  \"long long\": BigInt64Array,\n  \"long long int\": BigInt64Array,\n  \"signed long long\": BigInt64Array,\n  \"signed long long int\": BigInt64Array,\n  \"int64\": BigInt64Array,\n  \"int64_t\": BigInt64Array,\n  \"ulonglong\": BigUint64Array,\n  \"unsigned long long\": BigUint64Array,\n  \"unsigned long long int\": BigUint64Array,\n  \"uint64\": BigUint64Array,\n  \"uint64_t\": BigUint64Array,\n  \"float\": Float32Array,\n  \"double\": Float64Array\n}\n\n\n/**\n * This is the mapping from the NRRD datatype as written in the NRRD header\n * to the JS DataView binary reading methods.\n */\nconst BUFFER_READ_METHODS = {\n  \"signed char\": {\n    \"little\": 'readInt8',\n    \"big\": 'readInt8'\n  },\n  \"int8\": {\n    \"little\": 'readInt8',\n    \"big\": 'readInt8'\n  },\n  \"int8_t\": {\n    \"little\": 'readInt8',\n    \"big\": 'readInt8'\n  },\n  \"uchar\": {\n    \"little\": 'readUInt8',\n    \"big\": 'readUInt8'\n  },\n  \"unsigned char\": {\n    \"little\": 'readUInt8',\n    \"big\": 'readUInt8'\n  },\n  \"uint8\": {\n    \"little\": 'readUInt8',\n    \"big\": 'readUInt8'\n  },\n  \"uint8_t\": {\n    \"little\": 'readUInt8',\n    \"big\": 'readUInt8'\n  },\n  \"short\": {\n    \"little\": 'readInt16LE',\n    \"big\": 'readInt16BE'\n  },\n  \"short int\": {\n    \"little\": 'readInt16LE',\n    \"big\": 'readInt16BE'\n  },\n  \"signed short\": {\n    \"little\": 'readInt16LE',\n    \"big\": 'readInt16BE'\n  },\n  \"signed short int\": {\n    \"little\": 'readInt16LE',\n    \"big\": 'readInt16BE'\n  },\n  \"int16\": {\n    \"little\": 'readInt16LE',\n    \"big\": 'readInt16BE'\n  },\n  \"int16_t\": {\n    \"little\": 'readInt16LE',\n    \"big\": 'readInt16BE'\n  },\n  \"ushort\": {\n    \"little\": 'readUInt16LE',\n    \"big\": 'readUInt16BE'\n  },\n  \"unsigned short\": {\n    \"little\": 'readUInt16LE',\n    \"big\": 'readUInt16BE'\n  },\n  \"unsigned short int\": {\n    \"little\": 'readUInt16LE',\n    \"big\": 'readUInt16BE'\n  },\n  \"uint16\": {\n    \"little\": 'readUInt16LE',\n    \"big\": 'readUInt16BE'\n  },\n  \"uint16_t\": {\n    \"little\": 'readUInt16LE',\n    \"big\": 'readUInt16BE'\n  },\n  \"int\": {\n    \"little\": 'readInt32LE',\n    \"big\": 'readInt32BE'\n  },\n  \"signed int\": {\n    \"little\": 'readInt32LE',\n    \"big\": 'readInt32BE'\n  },\n  \"int32\": {\n    \"little\": 'readInt32LE',\n    \"big\": 'readInt32BE'\n  },\n  \"int32_t\": {\n    \"little\": 'readInt32LE',\n    \"big\": 'readInt32BE'\n  },\n  \"uint\": {\n    \"little\": 'readUInt32LE',\n    \"big\": 'readUInt32BE'\n  },\n  \"unsigned int\": {\n    \"little\": 'readUInt32LE',\n    \"big\": 'readUInt32BE'\n  },\n  \"uint32\": {\n    \"little\": 'readUInt32LE',\n    \"big\": 'readUInt32BE'\n  },\n  \"uint32_t\": {\n    \"little\": 'readUInt32LE',\n    \"big\": 'readUInt32BE'\n  },\n  \"longlong\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },           // OK for Node/V8/Chrome but not Firefox\n  \"long long\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },\n  \"long long int\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },\n  \"signed long long\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },\n  \"signed long long int\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },\n  \"int64\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },\n  \"int64_t\": {\n    \"little\": 'readBigInt64LE',\n    \"big\": 'readBigInt64BE'\n  },\n  \"ulonglong\": {\n    \"little\": 'readBigUInt64LE',\n    \"big\": 'readBigUInt64BE'\n  },\n  \"unsigned long long\": {\n    \"little\": 'readBigUInt64LE',\n    \"big\": 'readBigUInt64BE'\n  },\n  \"unsigned long long int\": {\n    \"little\": 'readBigUInt64LE',\n    \"big\": 'readBigUInt64BE'\n  },\n  \"uint64\": {\n    \"little\": 'readBigUInt64LE',\n    \"big\": 'readBigUInt64BE'\n  },\n  \"uint64_t\": {\n    \"little\": 'readBigUInt64LE',\n    \"big\": 'readBigUInt64BE'\n  },\n  \"float\": {\n    \"little\": 'readFloatLE',\n    \"big\": 'readFloatBE'\n  },\n  \"double\": {\n    \"little\": 'readDoubleLE',\n    \"big\": 'readDoubleBE'\n  }\n}\n\n\nexport {\n  NRRD_TYPES_TO_TYPEDARRAY,\n  BUFFER_READ_METHODS\n}\n","import { NRRD_TYPES_TO_TYPEDARRAY, BUFFER_READ_METHODS } from './constants'\n\n\n/**\n * Parse a buffer of a NRRD file.\n * Throws an exception if the file is not a proper NRRD file.\n * @param {ArrayBuffer} nrrdBuffer - the NRRD file buffer\n * @param {Object} options - the option object\n * @param {boolean} options.headerOnly - Parses only the header if true, parses header and data if false (default: false)\n * @return {Object} NRRD header and data such as {header: Object, data: TypedArray }\n */\nexport default function parse(nrrdBuffer, options){\n  let magicControl = 'NRRD000'\n  let magicTest = String.fromCharCode.apply(null, new Uint8Array(nrrdBuffer, 0, magicControl.length))\n\n  if(magicControl !== magicTest){\n    throw new Error('This file is not a NRRD file')\n  }\n\n  let {header, dataByteOffset} = parseHeader(nrrdBuffer)\n\n  if('headerOnly' in options && options.headerOnly ){\n    return header\n  }\n\n  console.log(dataByteOffset)\n\n\n}\n\n\n/**\n * Parse the header\n */\nfunction parseHeader(nrrdBuffer){\n  let byteArrayHeader = []\n  let dataStartPosition = null\n  let view = new DataView(nrrdBuffer)\n\n  for(let i=0; i<nrrdBuffer.byteLength; i++){\n    byteArrayHeader.push(String.fromCharCode(view.getUint8(i)))\n\n    if(i>0 && byteArrayHeader[i-1] === '\\n' && byteArrayHeader[i] === '\\n'){\n      dataStartPosition = i + 1\n      break\n    }\n  }\n\n  let headerLines = byteArrayHeader.join('').trim().split('\\n').map(l => l.trim())\n\n\n  let preMap = headerLines.slice(1)\n  .filter( s => { // removing empty lines\n    return s.length > 0\n  })\n  .filter( s => { // removing comments\n    return (s[0] !== '#')\n  })\n  .map( s => {\n    let keyVal = s.split(':')\n    return {\n      key: keyVal[0].trim(),\n      val: keyVal[1].trim()\n    }\n  })\n\n  let nrrdHeader = {}\n  preMap.forEach( field => {\n    nrrdHeader[field.key] = field.val\n  })\n\n\n  // parsing each fields of the header\n  if(nrrdHeader['sizes']){\n    nrrdHeader['sizes'] = nrrdHeader.sizes.split(' ').map( n => parseInt(n))\n  }\n\n  if(nrrdHeader['space directions']){\n    nrrdHeader['space directions'] = nrrdHeader['space directions'].split(' ')\n        .map(triple => {\n          if(triple.trim() === 'none'){\n            return null\n          }\n          return triple.slice(1, triple.length-1)\n                       .split(',')\n                       .map(n => parseFloat(n))\n        })\n  }\n\n  if(nrrdHeader['dimension']){\n    nrrdHeader['dimension'] = parseInt(nrrdHeader['dimension'])\n  }\n\n  if(nrrdHeader['space origin']){\n    nrrdHeader['space origin'] = nrrdHeader['space origin']\n        .slice(1, nrrdHeader['space origin'].length-1)\n        .split(',')\n        .map(n => parseFloat(n))\n  }\n\n  if(nrrdHeader['kinds']){\n    nrrdHeader['kinds'] = nrrdHeader['kinds'].split(' ')\n  }\n\n  if(nrrdHeader['space dimension']){\n    nrrdHeader['space dimension'] = parseInt(nrrdHeader['space dimension'])\n  }\n\n  return {\n    header: nrrdHeader,\n    dataByteOffset: dataStartPosition\n  }\n}\n","import parse from './Parser'\n\nexport default ({\n  parse,\n})\n"],"names":[],"mappings":"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"}